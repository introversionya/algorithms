# Алгоритмы

Алгоритмом называется набор инструкций для выполнения некоторой
задачи.

## Содержание:
- [Сложность алгоритма](#algorithmComplexity)
- [Бинарный поиск](#binarySearch)
- [Сортировка выбором](#selectionSorting)
- [Быстрая сортировка](#quickSort)

---


### <a id="algorithmComplexity"></a>Сложность алгоритма ###
Сложность алгоритма позволяет оценить за какое время выполнится код.

Пример записи:

``` javascript
O(n) /* Линейная сложность. Пример: бинарный поиск. */
O(Log n) /* Логарифмическая сложность. Пример: линейный поиск */
O(n * log n) /* Линейно-логарифмическая сложность. Пример: эффективные алгоритмы сортировки (быстрая
сортировка) */
O(n2) /* Квадратичная сложность. Пример: медленные алгоритмы сортировки (сортировка выбором) */
O(n!) /* Факториальная сложность. Пример: очень медленные алгоритмы */
```
* O(n) - Линейная сложность. Время работы равняется количеству данных. При таком подходе проверяется каждый элемент по порядку.
* O(Log n) - Логарифмическая сложность. Время работы алгоритма растет логарифмически с увеличением входных данных.
* O(n * log n) - Линейно-логарифмическая сложность. Время работы алгоритма равно произведению линейной и логарифмической сложностей.
* O(n2) - Квадратичная сложность. Время работы алгоритма пропорционально квадрату количества входных данных.
* O(n!) - Факториальная сложность. Время работы алгоритма пропорционально факториалу количества входных данных.

O - Время операции.
n - количество операций.


Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций.


---


### <a id="binarySearch"></a>Бинарный поиск ###
Представим, что у нас есть массив чисел от 0 до 100. Мы хотим найти число 50. Если начать перебор по порядку, то у нас получится 50 шагов, прежде чем найдем нужное число. Такой подход неоптимальный.

Пример линейного поиска:

``` javascript
const createArray = new Array(101).fill(0);
const array = createArray.map((value, index) => index);

for (let i = 0; i < array.length; i++) {
  console.log(`количество итераций: ${i}`); // 50 шагов
  if (array[i] === 50) break
}

// Сложность O(n)
```

Более эффективным способом будет использовать бинарный поиск.


Принцип алгоритма:

* Нужно обязательно отсортировать массив, если он еще не отсортирован
* Найти средний индекс массива
* Если текущий элемент массива меньше искомого числа, то исключаем левую половину массива
* Если текущий элемент массива больше искомого числа, то исключаем правую половину массива

Пример бинарного поиска:

``` javascript
const createArray = new Array(101).fill(0);
const array = createArray.map((value, index) => index);

function binarySearch(array, target) {
  let iterations = 0; // Количество итераций
  let start = 0; // Начальный индекс
  let end = array.length; // Конечный индекс
  let mid = null; // Средний индекс

  while(start <= end) {
    iterations++
    // Находим средний индекс массива
    mid = Math.floor((start + end) / 2)
    
    if (array[mid] === target) {
      console.log('iterations:', iterations) // Найдено за 1 шаг
      return mid
    } else if (array[mid] < target) {
      // Если элемент меньше искомого числа, то исключаем левую половину массива
      start = mid + 1;
    } else if (array[mid] > target) {
      // Если элемент больше искомого числа, то исключаем правую половину массива
      end = mid - 1;
    } else {
      return 'Ничего не нашлось:('
    }
  }
}

const result = binarySearch(array, 50);
console.log(result); // 50

// Сложность O(Log n)
```

---


### <a id="selectionSorting"></a>Сортировка выбором ###
Суть данного алгоритма - найти в цикле минимальное значение и поменять его местами с первым элементом.

Пример:
``` javascript
const arr = [8, 5, 9, 4, 7, 1, 3, 2, 6]

function selectionSort(arr) {
  for(let i = 0; i < arr.length; i++) {
    let minIdx = i;
    for(let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIdx]) {
        minIdx = j;
      }
    }
    let tmp = arr[i];
    arr[i] = arr[minIdx];
    arr[minIdx] = tmp;
  }
  return arr
}

const result = selectionSort(arr);
console.log(result); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// Сложность O(n^2)
```

---

### <a id="quickSort"></a>Быстрая сортировка ###
* Нужно выбрать опорный элемент, который разделяет массив на две части: левую и правую (в левой части все элементы < опорного элемента. В правой части все элементы > опорного элемента)
* Алгоритм работает рекурсивно до тех пор, пока длина массивов не будет равна 1
* Объединение двух полученных массивов в один

Пример:

``` javascript
const arr = [5, 8, 9, 4, 7, 1, 3, 2, 6];

function quickSort(arr) {
  // выход из рекурсии
  if (arr.length <= 1) return arr;

  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr[pivotIndex]; // Точка опоры, которая делит массив пополам
  const leftPart = []; // Левая часть массива
  const rightPart = []; // Правая часть массива

  for (let i = 0; i < arr.length; i++) {
    if (i === pivotIndex) {
      continue
    } else if (arr[i] < pivot) {
      leftPart.push(arr[i]);
    } else {
      rightPart.push(arr[i]);
    }
    
  }

  return [...quickSort(leftPart), pivot, ...quickSort(rightPart)]
}

const result = quickSort(arr);
console.log(result); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// Сложность O(n log n)
```